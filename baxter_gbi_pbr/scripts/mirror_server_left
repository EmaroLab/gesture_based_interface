#!/usr/bin/env python


## ROS node used to allow the user to control the baxter via mirroring using the data provided by the kinect (Rosbag for testing).


import argparse
import sys

import struct
import rospy

from baxter_gbi_pbr_msgs.msg import *
from baxter_gbi_pbr_srvs.srv import *

from baxter_interface import Limb, CHECK_VERSION
import baxter_interface
from baxter_gbi_pbr.limb_mover import NewLimbMover

from nav_msgs.msg import Odometry

import tf

from geometry_msgs.msg import (
    PoseStamped,
    Pose,
    Point,
    Quaternion,
)
from std_msgs.msg import Header

from baxter_core_msgs.srv import (
    SolvePositionIK,
    SolvePositionIKRequest,
)



   
global file_output

## Callback function associated with the topic 'mirror_end_effector'.
# Whenever a data is written in the topic, this function is called and obtain from ik_tracking function the joints values to assign and
# move the end effector to the goal.
#
# @param data.position: position we want to achieve.
# @param data.orientation: orientation we want to achieve (Quaternion).
def mirror_callback(data):
    
    global arm, limb
  
    pos = Point()
    pos.x = data.position.x
    pos.y = data.position.y
    pos.z = data.position.z
    
    global solver
        
    if (solver.iksolve(pos) == True):
        print("Solution is: "+str(solver.target_jts_dict))
        arm.move_to_joint_positions(solver.target_jts_dict)

    global file_output
    resp = arm.endpoint_pose()
    
    #file_output.write(str(resp['position'].x)+","+str(resp['position'].y)+","+str(resp['position'].z)+"\n")

  
##Main of the node. Takes the information from the topic and move the baxter end effector based on those values.
def mirror_server():
    
    rospy.loginfo("Initializing node... ")
    rospy.init_node('mirror_server_left')
    rospy.loginfo("Getting robot state... ")
    rs = baxter_interface.RobotEnable(CHECK_VERSION)
    init_state = rs.state().enabled
    rospy.loginfo("Enabling robot... ")
    rs.enable()
    
    rospy.loginfo("Mirror Server executed -> mirror service available.")
    
    
    global file_output
    file_output = open("baxter_data.csv","w+")
    

    global arm, limb
    limb = "left"
    arm = Limb(limb)
    global solver
    solver = NewLimbMover(limb)
    
    rospy.Subscriber("mirror_end_effector_left", mirror_end_effector, mirror_callback)
    
    def clean_shutdown():
        rospy.loginfo("\nExiting example...")
        if not init_state:
            rospy.loginfo("Disabling robot...")
            rs.disable()
        file_output.close()
    rospy.on_shutdown(clean_shutdown)

    rospy.spin()

if __name__ == "__main__":
    mirror_server()
