#!/usr/bin/env python2.7

## @package core
# . This package is the core application of the
#  state machine

import rospy
import signal
import baxter_gbi_input_msgs.msg as bgi_io
import smach
from std_srvs.srv import Trigger, TriggerResponse
from sensor_msgs.msg import Image as RosImage
import threading
from graphviz import Digraph
import std_msgs
from mttkinter import mtTkinter as tk
from PIL import Image, ImageTk
from gbi_states import *
from parser import *
import cv2
from cv_bridge import CvBridge, CvBridgeError


##  class FSMThread
#   inherited form threaing.Thread

class ImageConverter(object):
    @staticmethod
    def to_ros(img):
        rosimage = RosImage()
        bridge = CvBridge()
        image = cv2.imread(img)
        rosimage = bridge.cv2_to_imgmsg(image, encoding="bgr8")
        return rosimage


class FSMThread(threading.Thread):
    ## the constructor
    def __init__(self):
        threading.Thread.__init__(self)

        smach.set_loggers(smach.loginfo, smach.logwarn, self.logdebug, smach.logerr)
        self.subscr = rospy.Subscriber("/beacons/presence", std_msgs.msg.Header, self.presence_cb, callback_args=[self])
        ## attribute to manage the graph in graphviz
        self.imageFile = "state_machine"
        self.imageFile1 = "play_state"
        self.imageFile2 = "record_machine"
        self.imageFile3 = "macro_machine"
        self.imageFile4 = "sequence_machine"

        self.image_publisher = rospy.Publisher('/fsm/image', RosImage, queue_size=1)

        self.f = Digraph('finite_state_machine', filename='state_machine.gv', format='png')
        # self.f.attr('graph', dpi="180")
        self.f.attr(rankdir='TB', size="12")
        self.f.attr('node', shape='circle', style='filled', fontsize='25', heigth='1.2', width='1.6', color='lightblue')
        self.f.attr('edge', style='bold', fontsize='0', arrowsize='1.5')

        self.f1 = Digraph('play_state', filename='play_state.gv', format='png')
        self.f1.attr('node', shape='circle', style='filled', fontsize='25', heigth='1.2', width='1.6', color='lightblue')
        self.f1.attr('edge', style='bold', fontsize='0', arrowsize='1.5')

        self.f2 = Digraph('record_state', filename='record_state.gv', format='png')
        self.f2.attr('node', shape='circle', style='filled', fontsize='25', heigth='1.2', width='1.6', color='lightblue')
        self.f2.attr('edge', style='bold', fontsize='0', arrowsize='1.5')

        self.f3 = Digraph('macro_state', filename='macro_state.gv', format='png')
        self.f3.attr('node', shape='circle', style='filled', fontsize='25', heigth='1.2', width='1.6', color='lightblue')
        self.f3.attr('edge', style='bold', fontsize='0', arrowsize='1.5')

        self.f4 = Digraph('sequence_state', filename='sequence_state.gv', format='png')
        self.f4.attr('node', shape='circle', style='filled', fontsize='25', heigth='1.2', width='1.6', color='lightblue')
        self.f4.attr('edge', style='bold', fontsize='0', arrowsize='1.5')

        self.event = FsmEvent()

        parser = Parser(gbi_states, self.event)
        self.sm, machines = parser.parse()
        self.sm.register_transition_cb(self.transition_cb)
        self.sub_play = machines['PLAY']
        self.sub_record = machines['RECORD']
        self.sub_macro = machines['MACRO']
        self.sub_sequence = machines['SEQUENCE']

        self.sub_play.register_transition_cb(self.transition_cb1)
        self.sub_record.register_transition_cb(self.transition_cb2)
        self.sub_macro.register_transition_cb(self.transition_cb3)
        self.sub_sequence.register_transition_cb(self.transition_cb4)
        self.sub_play.register_start_cb(self.transition_cb1)
        self.sub_record.register_start_cb(self.transition_cb2)
        self.sub_macro.register_start_cb(self.transition_cb3)
        self.sub_sequence.register_start_cb(self.transition_cb4)

    def logdebug(self, msg):
        pass

    def rendering(self, filename, active_states, f):
        print filename
        if active_states:
            f.node(active_states[0], color="red", shape='doublecircle', style='filled')
        f.render(filename=filename, directory=None, view=False, cleanup=True, format='png')
        if active_states:
            f.node(active_states[0], color="lightblue", shape='circle', style='filled')
        image = ImageTk.PhotoImage(Image.open(filename + ".png"))
        w = image.width()
        h = image.height()
        self.panel.configure(image=image)
        self.panel.pack(side=tk.TOP, fill=tk.BOTH, expand=tk.YES)
        self.display = image
        self.widget.geometry("%dx%d+%d+%d" % (w, h, 0, 0))
        self.widget.update()
        image_message = ImageConverter.to_ros(filename+'.png')
        self.image_publisher.publish(image_message)


    ## method register_transition_cb
    #  @param userdata data of used from the active state
    #  @param active_states list of the active states after the transition
    #  @param *cb_args additional arguments
    def transition_cb(self, userdata, active_states, *cb_args):
        self.rendering(self.imageFile, active_states, self.f)

    def transition_cb1(self, userdata, active_states, *cb_args):
        self.rendering(self.imageFile1, active_states, self.f1)

    def transition_cb2(self, userdata, active_states, *cb_args):
        self.rendering(self.imageFile2, active_states, self.f2)

    def transition_cb3(self, userdata, active_states, *cb_args):
        self.rendering(self.imageFile3, active_states, self.f3)

    def transition_cb4(self, userdata, active_states, *cb_args):
        self.rendering(self.imageFile4, active_states, self.f4)

    ## method presence_cb
    #  @param msg message of the topic
    #  @param params list of parameters
    def presence_cb(self, msg, params):
        self.event.signal('user_detected')

    ## method config_cb
    #  @param req rquest from service
    def config_cb(self, req):
        self.event.signal('config')
        # FIXME wait for state machine transition outcome
        return TriggerResponse(success=True, message="ciao")

    ## method run
    def run(self):
        ## equal to rendering but with tk.label and panle.pack to generate the label and the background space

        self.widget = tk.Tk()
        self.panel = tk.Label(self.widget)
        self.widget.title('State_Machine')
        self.rendering(self.imageFile, ['INIT'], self.f)
        rospy.Service('/fsm_config', Trigger, self.config_cb)
        self.sm.execute()

    ## method stop
    def stop(self):
        self.sm.request_preempt()
        while self.sm.is_running():
            pass

    ## method graph_gen
    #  graph generation
    def graph_gen(self):
        tr_edge = self.sm.get_internal_edges()
        tr_edge1 = self.sub_play.get_internal_edges()
        tr_edge2 = self.sub_record.get_internal_edges()
        tr_edge3 = self.sub_macro.get_internal_edges()
        tr_edge4 = self.sub_sequence.get_internal_edges()

        self.f.node(self.sm.get_initial_states()[0])
        for i in range(0, len(tr_edge)):
            self.f.edge(tr_edge[i][1], tr_edge[i][2], label=tr_edge[i][0])
        for i in range(0, len(tr_edge1)):
            self.f1.edge(tr_edge1[i][1], tr_edge1[i][2], label=tr_edge1[i][0])
        for i in range(0, len(tr_edge2)):
            self.f2.edge(tr_edge2[i][1], tr_edge2[i][2], label=tr_edge2[i][0])
        for i in range(0, len(tr_edge3)):
            self.f3.edge(tr_edge3[i][1], tr_edge3[i][2], label=tr_edge3[i][0])
        for i in range(0, len(tr_edge4)):
            self.f4.edge(tr_edge4[i][1], tr_edge4[i][2], label=tr_edge4[i][0])


## function config_server
#  ros node
t = None
def config_server():
    rospy.init_node('config_server')
    t = FSMThread()
    t.graph_gen()
    t.start()
    rospy.on_shutdown(t.stop)
    rospy.spin()

if __name__ == "__main__":
    config_server()
